# 10 套

## [P4728 [HNOI2009] 双递增序列](https://www.luogu.com.cn/problem/P4728) (Hard)

TODO:

## [P4881 hby与tkw的基情](https://www.luogu.com.cn/problem/P4881) (Easy)

> $T$ 组数据。给定 $n$，计算 $\sum\limits_{i=1}^{\frac {n+1} 2} (2i-1) \times 26^i$。答案 $\bmod (10^9 + 7)$。
>
> $T \le 5 \times 10^5$。$n \le 10^9$。

其他部分是弱智，我们重点关注怎么计算这个式子：

$$\sum n a^n \delta n$$

我们使用分部求和公式：

$$\sum u \Delta v = uv - \sum \mathrm Ev \Delta u$$

令 $u = n$，$v = \frac {a^n} {a-1}$：

$$\begin{aligned}
    & \sum n a^n \delta n \\
    =& n \times \frac {a^n} {a-1} - \sum \frac {a^{n+1}} {a-1} \delta n \\
    =& n \times \frac {a^n} {a-1} - \frac {a^{n+1}} {(a-1)^2} + C \\
    =& \frac {a^n (an - a - n)} {(a - 1)^2} + C \\
\end{aligned}$$

直接快速幂 $O(T \log n)$ 做掉，或者光速幂 $O(\sqrt n + T)$ 做掉。

## [P7864 「EVOI-RD1」摘叶子](https://www.luogu.com.cn/problem/P7864) (Ad-hoc)

> 给定一棵 $n$ 个节点的树，根为 $1$。Alice 和 Bob 博弈，Alice 先手：每次可以选择任意数量的叶子（不能不选）删除，最终删除根节点的获胜。求谁获胜。
>
> $n \le 10^6$。

这个题没有明显的子问题的样子，所以 SG 函数相关的思路走不通。应该是纯构造的人类智慧。

TODO:


注意大多数时候先手必胜，打表打出先手必败的情况，有明显规律。

# 11 套

## [P5675 [GZOI2017] 取石子游戏](https://www.luogu.com.cn/problem/P5675) (Easy)

> 有 $n$ 堆石子，第 $i$ 堆有 $a_i$ 个。你要选择一些石子堆，Alice 和 Bob 会在这些石子堆上玩 Nim 游戏，Alice 是先手，并且同时你还可以决定 Alice 第一次要从哪一堆取（但是不能决定取的数量）。
>
> 求有多少种方案（选择的石子堆集合不同，或指定 Alice 第一次要取的石子堆不同，则方案不同），使得 Alice 不能获胜。
>
> $n \le 200$，值域 $200$。
>
> 加强：$O(n V \log V)$。

Nim 游戏的结论是：一个状态是必败状态当且仅当 $\bigoplus a_i = 0$。

必败不太好做，考虑做必胜。

我们考虑枚举 Alice 第一次要取的石子堆，假设这堆有 $x$ 个。令剩下的石子堆异或和为 $S$，则这个状态必胜当且仅当 $\exists y \in [0,x)$ 有 $y \oplus S = 0$，即 $S < x$。

我们考虑维护除去这堆以外的剩下堆的线性基 $B$。我们可以维护前缀线性基和后缀线性基，将其 $O(\log^2 V)$ 合并。

设 $B$ 有 $k$ 个自由元。枚举 $S \in [0,256)$，若 $S$ 可以被 $B$ 表出，则表出的方案数是 $2^k$。这一步时间复杂度 $O(V \log V)$。

时间复杂度 $O(n V \log V)$。

## [P2570 [ZJOI2010] 贪吃的老鼠](https://www.luogu.com.cn/problem/P2570) (Lunatic)



$n,m \le 30$，网络流



## [P8575 「DTOI-2」星之河](https://www.luogu.com.cn/problem/P8575) (Easy)

> 给定一棵 $n$ 个节点的树，根节点为 $1$。每个节点 $u$ 有两个权值 $a_u, b_u$。
>
> 对于每个节点，求出 $ans_u$ 表示有几个节点 $v$ 满足：
> - $v$ 在 $u$ 的子树内。
> - $a_v \le a_u$。
> - $b_v \le b_u$。
>
> $n \le 2 \times 10^5$。

我们发现链的做法就是三维偏序模板，所以这个题起码 2log 了。

对于树的情况，我们考虑转化为三维偏序。我们可以用 DFS 序刻画“$v$ 在 $u$ 子树内”的条件。

做完了。时间复杂度 $O(n \log^2 n)$。

# 12 套

## [P2594 [ZJOI2009] 染色游戏](https://www.luogu.com.cn/problem/P2594) (Ad-hoc)

https://www.luogu.com/article/6apzxhu6

https://www.cnblogs.com/dyhaohaoxuexi/p/14418900.html

## [P10102 [GDKOI2023 提高组] 矩阵](https://www.luogu.com.cn/problem/P10102) (Ad-hoc)

> $T$ 组数据。给定 $n \times n$ 矩阵 $A,B,C$，求是否 $A \times B = C$。
>
> 所有运算在 $\bmod 998244353$ 意义下进行。
>
> $\sum n \le 3000$。

直接做是 $O(n^3)$ 的，肯定不行。考虑随机化。

我们想到一个经典套路：矩阵乘向量是 $O(n^2)$ 的。

我们随机若干个向量 $\vec x$，求是否 $AB \vec{x} = C \vec{x}$，若不相等则**必定**答案为 No，若相等则答案**大概率**为 Yes。

错误率呢？

我们的检验本质上是求 $\vec x$ 是否在 $AB - C$ 的 null space 中。

$$\dim N(AB-C) = n - \text{rank}(AB-C) \le n-1$$

$$\lvert N(AB-C) \rvert \le p^{n-1}$$

$$P_{\text{Error}} = \frac {\lvert N(AB-C) \rvert} {p^n} \le \frac 1 p$$

这题中 $p = 998244353$，一个 $\le \frac 1 p$ 的错误率可接受。如果 $p$ 更小，多跑几次即可。

时间复杂度 $O(n^2)$。

## [P4983 忘情](https://www.luogu.com.cn/problem/P4983) (Easy)

> 给定一个长度为 $n$ 的序列 $a$。给定参数 $m$，将序列不重不漏分成 $m$ 段，令每段的贡献为以下式子：
>
> $$(1 + \sum\limits_{i=l}^r a_i)^2$$
>
> 求最小贡献和。
>
> $m \le n \le 10^5$，$1 \le a_i \le 10^3$。

首先我们相信答案关于 $m$ 下凸，我们使用 WQS 二分去掉 $m$ 的性质。$\lambda$ 的上界可以取 $(s_r + 1)^2$。

我们 DP 求解不带限制的答案：

$$f_i = \min_{j \in [0,i)} (f_j + (s_i - s_j + 1)^2 + \lambda)$$

其中 $s$ 为 $a$ 的前缀和。

一眼看出这个东西可以斜率优化，$O(n)$。

时间复杂度 $O(n \log (nV)^2) = O(n (\log n + \log V))$。

# 13 套

## [P3708 koishi的数学题](https://www.luogu.com.cn/problem/P3708)✅️ (Easy)

> 对于所有 $x \in [1,n]$，求出 $\sum\limits_{i=1}^n (x \bmod i)$。
>
> $n \le 10^6$。

做过。可以转化为 $\sigma$ 的前缀和问题。

时间复杂度 $O(n)$。

## [P3709 大爷的字符串题](https://www.luogu.com.cn/problem/P3709) (Easy)

> 对于一个序列，我们定义其权值：
>
> 初始时权值为 $0$。维护一个集合 $S$，初始为空。重复执行以下操作直到序列为空：
> - 你任意选择序列中一个数 $x$。
> - 将 $x$ 从从原序列删除。
> - 若 $S$ 为空，权值 +1。
> - 若 $S$ 有大于等于 $x$ 的元素，权值 +1，清空 $S$。
> - 将 $x$ 插入 $S$。
>
> 给定一个序列，多次询问区间最小权值。
>
> $n,m \le 2 \times 10^5$。

我们发现这个最小权值可以这么描述：用最少的严格上升序列覆盖原集合。

根据 Dilworth 定理，这等于其最长反链的长度。由于我们可以随便安排顺序，那么最长反链长度就是其**众数出现次数**。（这部分是 [P11231 [CSP-S 2024] 决斗](https://www.luogu.com.cn/problem/P11231)）

莫队解决。

令 $n,m$ 同阶，时间复杂度 $O(n \sqrt n)$。

## [P1393 Mivik 的标题](https://www.luogu.com.cn/problem/P1393)🟡 (Hard)

> 给定一个长为 $m$ 的模式串和字符集大小 $\lvert \Sigma \rvert$。求有几个长为 $n$ 的主串包含该模式串。
>
> 答案对 $998244353$ 取模。
>
> $n \le 2 \times 10^5$，$m \le 10^5$，$\lvert \Sigma \rvert \le 10^8$。
>
> 注：本题有一个简单版本，$n \le 10^9$，$m \le 20$，$\lvert \Sigma \rvert = 10$。[P3193 [HNOI2008] GT考试](https://www.luogu.com.cn/problem/P3193)

$O(? + m^3 \log n)$

$O(nm)$


TODO:

# 14 套

## [P1129 [ZJOI2007] 矩阵游戏](https://www.luogu.com.cn/problem/P1129) (Easy)

> 有一个 $n \times n$ 的黑白方阵。你可以无限制地交换任意两行或者任意两列，目标是使得主对角线上全是黑格。判断是否有解。
>
> $n \le 200$。

不难发现，同行关系不改变，同列关系也不改变。因此主对角线的格子在原方阵上也是不同行不同列的 $n$ 个格子。

很容易发现这是一个二分图最大匹配，$O(n^2 \sqrt n)$ Dinic 即可。



## [P11761 [IAMOI R1] 明码标价](https://www.luogu.com.cn/problem/P11761) (Normal)



## [P11770 檐牙覆雪](https://www.luogu.com.cn/problem/P11770) (Hard)

> $T$ 组数据。有一个长为 $n$ 的数组 $a$ 满足
>
> $$a_i = 1 + \max\limits_{d|i, d \ne i} (a_d + (\lfloor \frac n d \rfloor - \frac i d))$$
>
> 边界 $a_1 = 1$。
>
> 求出 $f(n) = \sum_{i=1}^n a_i$。
>
> $T \le 5 \times 10^5$，$n \le 2 \times 10^6$。

打个表看转移，可以看出以下关系：

$$a_i = a_{i/p_i} + \lfloor \frac n {i/p_i} \rfloor - p_i + 1$$

其中 $p_i$ 是 $i$ 的最大质因子。（不证明。）

仿照 [P3708 koishi的数学题](https://www.luogu.com.cn/problem/P3708) 的思路，我们将所有 $n$ 排序，考虑当 $n$ 变为 $n+1$ 的时候，会发生什么变化。

当 $\frac i {p_i}$ 恰为 $n+1$ 的约数时，$\lfloor \cdot \rfloor$ 的项会 $+1$。这会使得 $a_i$ 被 $+1$，以及 $a_i$ 能转移到的后续 $a$ 也被 $+1$。

“$\frac i {p_i}$ 恰为 $n+1$ 的约数”只会发生 $O(n \log n)$ 次，这保证了改变的时间复杂度。接下来考虑刻画对后续项的改变。

我们发现 $a$ 的转移构成一棵树，因此记一下子树 $siz$ 即可。

时间复杂度 $O(n \log n)$。

# 15 套

## [P11774 [COTS 2013] 矩形覆盖 / BAKTERIJE](https://www.luogu.com.cn/problem/P11774) (Easy)



## [P11795 [JOI 2016 Final] 铁路票价 / Train Fare](https://www.luogu.com.cn/problem/P11795) (Easy)



## [P11922 [PA 2025] 叠积木 / Wieża](https://www.luogu.com.cn/problem/P11922) (Easy)

> $n$ 个积木，第 $i$ 个积木高度 $a_i$，颜色 $w_i$。
>
> 选出一个 $\langle 1, \dots, n \rangle$ 的子序列 $p$，设这个子序列长度为 $m$，你需要保证 $a$ 上对应的子序列**严格递增**。
>
> 给定**正**整数 $c$。最大化：
>
> $$\sum_{1 \le i \le m} a_{p_i} - c \sum_{1 \le i < m} [w_{p_i} \ne w_{p_{i+1}}]$$
>
> $n \le 5 \times 10^5$。

TODO:

树状数组优化 DP，$O(n \log n)$

注意到，$O(n)$

# 16 套

## [P11895 「LAOI-9」Sequence](https://www.luogu.com.cn/problem/P11895) (Ad-hoc)

## [P11431 [COCI 2024/2025 #2] 差异 / Različitost](https://www.luogu.com.cn/problem/P11431) (Hard)

> 给定长为 $n,m$ 的序列 $a,b$ 和一个参数 $k$，求
>
> $$\sum_{i=1}^k (a_{i \bmod n} \oplus b_{i \bmod m})$$
>
> 答案对 $10^9 + 7$ 取模。
>
> $n,m \le 2 \times 10^5$，$k \le 10^{18}$，$0 \le a_i, b_i \le 10^{18}$。

每一位独立，直接拆开。

注意到有循环节 $\text{lcm}(n,m)$，因此我们接下来只关注 $k < \text{lcm}(n,m)$ 的情况。

我们令 $x = i \bmod n$，那么 $i$ 可以被表示为 $t \times n + x$。我们固定 $x$ 观察 $i$。

这里是一个经典的模型：**双模数**（模板题 [P5330 [SNOI2019] 数论](https://www.luogu.com.cn/problem/P5330)）。对于 $[0,m)$ 每个数建一个点，每个点 $i$ 连边到 $(i + n) \bmod m$，则整张图是 $\gcd(n,m)$ 个环，每个环环长为 $\frac m {\gcd(n,m)}$。

即，固定 $x$ 时，对应的 $y = i \bmod m$ 在 $t$ 变化时呈现长度为 $\frac m {\gcd(n,m)}$ 的循环。

我们预处理环上的前缀和，查询 $\frac {k-x} n$ 的位置即可。

TODO: $n < m$

TODO:

时间复杂度 $O((n+m) \log V)$，$\log V$ 来自拆位，双模数自身是线性的。

## [P11457 [USACO24DEC] Job Completion G](https://www.luogu.com.cn/problem/P11457)✅️ (Normal)

> 有 $n$ 个任务，第 $i$ 个任务要在 $s_i$ 秒及之前开始，连续做 $t_i$ 秒完成。一次只能做一个任务。求最多能做几个任务。
>
> $n \le 2 \times 10^5$，$0 \le s_i,t_i \le 10^{18}$。
>
> 双倍经验：[P4053 [JSOI2007] 建筑抢修](https://www.luogu.com.cn/problem/P4053)

首先一眼看出是贪心，因为 DP 肯定没法做。

设计贪心。对于两个任务 $i,j$，若 $j$ 放在前会使得 $i$ 无法完成，但是 $i$ 放在前面可以完成，则我们设计的排序需要保证能够区分出这种情况。

形式化说，设当前时间为 $cur$，对于 $cur + t_j > s_i$ 且 $cur + t_i \le s_j$ 的情况，我们要令 $i$ 排在 $j$ 前面。把两个不等式合并得到

$$s_i + t_i < s_j + t_j$$

因此我们把所有任务按照 $s + t$ 升序排序，然后看具体怎么选。

---

每次新加入一个任务 $i$，有两种可能：直接就能做，那就做；时间不够，做不了。对于后者，我们知道答案已经不可能增加了，但是我们要为后面做准备。我们可以做的事是踢掉一个做过的任务（只会踢一个，踢多了答案劣），即**反悔贪心**。

很显然后面发生的一切都只和 $cur$ 有关，所以我们要让后面的 $cur$ 尽量小。因此我们踢掉一个 $t$ 最大的。

```cpp
    sort(a+1, a+n+1, [](Task &A, Task &B) {
        return A.s + A.t < B.s + B.t;
    });
    ll cur = 0; int ans = 0;
    priority_queue<ll> pq;
    rep(i, 1, n) {
        auto [s, t] = a[i];
        pq.push(t);
        if (cur <= s)
            ans++;
        else
            cur -= pq.top(), pq.pop();
        cur += t;
    }
    cout << ans << '\n';
```