# 内置函数

注意这些函数的参数都是 `unsigned int` 类型，如果传入 `int` 注意不要传入负数（强制转换之后可能比较诡异），$0$ 的情况也要小心。

注意这些函数有对应的 `ll` 版本，如 `__builtin_popcountll`，接受 `unsigned long long` 类型参数，也要小心前面的问题。

- `__builtin_popcount(x)`：Population Count，$x$ 中 $1$ 的个数。
- `__builtin_clz(x)`：Count Leading Zeros，$x$ 的前导零个数（与位长有关）。
- `__builtin_ctz(x)`：Count Trailing Zeros，$x$ 的“后导零”个数，即 $x$ 末尾有几个 $0$。

# 二进制技巧

- $\text{lowbit}(x) = $ `x & -x`
- $\log_2 \text{lowbit}(x) = $ `1 << ctz(x)`
  - 注意 $x=0$ 时两侧都无定义。
- 枚举 $x$ 有哪些位是 $1$ 时，搭配以上两个技巧可以做到 $O(ans)$（优于 $O(w)$）的复杂度。
  - 这在状压 DP 时可能可以均摊掉复杂度。

# 集合的最大异或对

> 给定集合 $S$，取出两个数 $x,y$ 使得 $x \oplus y$ 最大。
>
> 例题：[P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)

维护一个 01Trie，把元素依次加入，每次加入的时候贪心算一下该元素和之前元素能产生的最大异或对。在所有最大异或对中再取出最大的一个。

时间复杂度 $O(n \log V)$。

# 集合的最小异或对

> 给定集合 $S$，取出两个数 $x,y$ 使得 $x \oplus y$ 最小。
>
> 例题：[[ABC308G] Minimum Xor Pair Query](https://www.luogu.com.cn/problem/AT_abc308_g)

首先有一个同上的做法（时间复杂度 $O(n \log V)$），但是最小异或对还有另一种思路：

有结论——对于 $x < y < z$，$\min(x \oplus y, y \oplus z) < x \oplus z$。

因此把集合排序，答案只会在相邻位置对出现。时间复杂度 $O(n \log n)$。

往往配合其它数据结构使用，比如例题的平衡树。

# 单点修改 & 高维前缀和

> - 往集合 $S$ 插入一个二进制数。
> - 给定一个 $x$，求 $\sum\limits_{y \in S} [x \subseteq y]$。
>
> 值域 $2^k$。

设 $f_{A,B}$ 表示有几个二进制数前一半**等于** $A$ 后一半**包含** $B$，显然 $A,B$ 值域均为 $O(\sqrt 2^k)$。
- 插入时 $A$ 确定，枚举 $B$，时间复杂度 $O(\sqrt 2^k)$。
- 查询时 $B$ 确定，枚举 $A$，时间复杂度 $O(\sqrt 2^k)$。

空间复杂度 $O(2^k)$。