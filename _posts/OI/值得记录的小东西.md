# DFS 序 LCA

当 $u = v$ 时 $\text{LCA}(u,v) = u$；否则，$\text{LCA}(u,v)$ 是满足 $dfn_x \in [dfn_u + 1, dfn_v]$ 的节点 $x$ 中深度最小的节点的父亲。

时间复杂度 $\Theta(n \log n) - \Theta(1)$。

# 树上背包

> [P2014 [CTSC1997] 选课](https://www.luogu.com.cn/problem/P2014) \| [U53204 【数据加强版】选课](https://www.luogu.com.cn/problem/U53204)
>
> 有 $n$ 个点，每个点 $u$ 有 $a_u$ 的权值。每个点有 $0$ 或 $1$ 个父亲，只有拿了父亲才能拿这个点。求选择 $m$ 个点的最大权值和。

首先先把没有父亲的点都连到一个根 $0$ 上，这样就把森林问题转化为树问题。

设 $f_{u,i}$ 为点 $u$ 的子树内背包大小为 $i$ 的答案。最终答案即为 $f_{0,m}$。

很容易写出状态转移方程：

```cpp
    siz[u] = 1;
    f[u][1] = a[u];
    for (auto v : G[u]) {
        dfs(v);
        per(i, min(siz[u], m), 1)
            rep(j, 1, min(siz[v], m-i))
                cmax(f[u][i+j], f[u][i] + f[v][j]);
        siz[u] += siz[v];
    }
```

可以证明，这个写法的时间复杂度是 $O(nm)$ 的。

# DAG 可达性统计（传递闭包）

[P10480 可达性统计](https://www.luogu.com.cn/problem/P10480)

从没有出边的点开始 DP。因此建反图拓扑排序，用 bitset 维护。时间复杂度 $O(\frac {nm} w)$。

# 有向图 可达性统计

缩点，变成 DAG 可达性统计，$O(\frac {nm} w)$。

如果是稠密图，跑 Floyd 直接 $\Theta(\frac {n^3} w)$。

# 暴力：DAG 拓扑序计数

[[ABC041D] 徒競走](https://www.luogu.com.cn/problem/AT_abc041_d)

可以做到 $\Theta(n 2^n)$。

具体地，设 $f_S$ 表示点集 $S$ 的拓扑序数。

对于点集 $S$，枚举个节点 $u$，若 $u$ 的所有儿子都在 $S$ 内，且 $u$ 自身不在，则

$$f_{S \cup \{u\}} += f_S$$

# 代码

## DFS 序 LCA

```cpp
int dfn[MAXN], tick;
int Min(int u, int v) {
    if (dfn[u] < dfn[v])
        return u;
    return v;
}
struct SparseTable {
    int f[LOGN][MAXN];
    void build() {
        for (int i = 1; (1 << i) <= n; i++)
            for (int j = 1; j + (1 << i) - 1 <= n; j++)
                f[i][j] = Min(f[i-1][j], f[i-1][j + (1 << (i-1))]);
    }
    int query(int l, int r) {
        int i = __lg(r - l + 1);
        return Min(f[i][l], f[i][r - (1 << i) + 1]);
    }
} st;
void dfs(int u, int fa) {
    dfn[u] = ++tick;
    st.f[0][dfn[u]] = fa;
    for (auto v : G[u]) if (v != fa)
        dfs(v, u);
}

int LCA(int u, int v) {
    if (u == v)
        return u;
    if (dfn[u] > dfn[v])
        swap(u, v);
    return st.query(dfn[u] + 1, dfn[v]);
}
```

## DAG 可达性统计（传递闭包）

```cpp
int n, m;
vector<int> G[MAXN];
int in[MAXN];

bitset<MAXN> f[MAXN];

int main() { ios::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    rep(i, 1, m) {
        int u, v; cin >> u >> v;
        G[v].push_back(u), in[u]++;
    }

    queue<int> q;
    rep(u, 1, n) {
        if (in[u] == 0)
            q.push(u);
        f[u].reset(), f[u][u] = 1;
    }
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto v : G[u]) {
            f[v] |= f[u];
            in[v]--;
            if (in[v] == 0)
                q.push(v);
        }
    }

    rep(u, 1, n)
        cout << f[u].count() << '\n';
    return 0;
}
```

## DAG 拓扑序计数

```cpp
int main() { ios::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    rep(i, 1, m) {
        int u, v; cin >> u >> v; u--, v--;
        G[u] |= (1 << v);
    }

    int tot = (1 << n) - 1;

    f[0] = 1;
    rep(mask, 0, tot)
        rep(u, 0, n-1)
            if ((G[u] & mask) == G[u] and !(mask >> u & 1))
                f[mask | (1 << u)] += f[mask];
    cout << f[tot] << '\n';
    return 0;
}
```