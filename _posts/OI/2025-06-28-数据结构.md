---
title: '数据结构'
date: 2025-06-28
permalink: /posts/2025/06/2025-06-28-数据结构/
excerpt: "跳表、Splay、Treap、LCT。"
tags:
  - OI
---

✅️代表此题已完成（写好代码 AC）。

# 跳表 (Skip List)

小常数数据结构，可以当平衡树用。优势在于对于单次操作，动态开点权值线段树 $O(\log V)$，跳表是期望 $O(\log n)$。

<https://oi-wiki.org/ds/skiplist/>

没啥用，不写了。

# 平衡树 Intro

[P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369) \| [P6136 【模板】普通平衡树（数据加强版）](https://www.luogu.com.cn/problem/P6136) ✅️

众所周知 BST 是一种非常方便的结构，但是唯一的问题是树高不对。

也就是说，只要树高能一直保持 $O(\log n)$ 就行了，顺着这样的思路，出现了 AVL 和 Treap。

## Rotate 操作

<img src="https://oi-wiki.org/ds/images/splay-rotate.svg" width="300"/>

Rotate 操作不改变树的中序遍历，即一棵 BST 在任意 rotate 之后还是一棵 BST。基于 rotate 操作我们可以调整树的深度。

# AVL

**满足每个节点的两个儿子的高度差绝对值 $\le 1$ 的二叉树，树高为 $O(\log n)$。**

没啥用，不写了。大致思想就是插入之后不满足上面那个条件的时候，rotate 一下调整。

# Treap

**把一个长为 $n$ 的序列随机打乱，然后按顺序插入二叉查找树中，那么这颗二叉查找树树高期望为 $\Theta(\log n)$。**

没啥用，不写了。好像说 Treap 常数比 Splay 小。

# Splay

参考：
- [OI Wiki 的 Splay](https://oi-wiki.org/ds/splay/)
- [严格鸽 的 Splay](https://zhuanlan.zhihu.com/p/556896902)（码风比较好！）
- [朝夕 的 Splay](https://zhuanlan.zhihu.com/p/346741421)
- 在写完之后才找到的一篇 [Menci 老师的](https://oi.men.ci/splay-notes-1/)
- [一篇非常完整的平衡树资料](https://www.luogu.com.cn/article/ke61fxry)

## 简单操作：dir, pushup, rotate

```cpp
bool dir(int u) {
    // 若 u 为左儿子返回 0，若 u 为右儿子返回 1
    return u == tr[fa[u]][1];
}
void pushup(int u) {
    siz[u] = cnt[u] + siz[tr[u][0]] + siz[tr[u][1]];
    // cnt 为这个节点的大小，即这个节点代表的值出现了几次
}
```

有了 `dir` 之后，`rotate` 就很好实现了：

```cpp
void rotate(int u) {
    int v = fa[u], w = fa[v];
    bool r = dir(u);

    // 更新树结构 tr
    tr[v][r] = tr[u][!r];
    tr[u][!r] = v;
    if (w) tr[w][dir(v)] = u;

    // 更新对应的 fa
    fa[u] = w;
    fa[v] = u;
    if (tr[v][r]) fa[tr[v][r]] = v;

    pushup(v), pushup(u); // 先 v 再 u
}
```

## splay

接下来介绍 Splay 的核心操作：`splay(u, target)`，意思是想办法进行 rotate 直到 `fa[u] == target`。特别地，`splay(u)` 代表把 $u$ 弄成根，即 `fa` 是 $0$。

这一段涉及到复杂度分析，所以我们直接背代码：

```cpp
void splay(int u, int target = 0) {
    while (fa[u] != target) {
        int v = fa[u];
        if (fa[v] != target)
            // fa[u] 已经是 target 的儿子时，不需要这一步
            rotate(dir(u) == dir(v) ? v : u);
            // 若 u,fa[u],fa[fa[u]] 三点共线，转 fa[u]；否则转 u
        rotate(u); // 不管怎么样都要转 u
    }
    if (!target)
        root = u;
}
```

根据老师的 PPT，$n$ 个点执行 $m$ 次 `splay` 的复杂度是 $O((n+m) \log n)$。也就是说均摊下来是 $\log$ 的。

也正因为此，我们接下来的功能设计都要围绕 `splay` 操作展开。**切记每次操作做完的时候都把当前的节点 `splay` 上去**。~~飞起来！~~

警告：Splay 和无旋 Treap 之类的树不同，Splay 实现时各种操作互相耦合，需要整理好逻辑。我的整体逻辑借鉴了朝夕的文章（在上面的参考文章当中）。TODO: 如果以后发现了更好的实现逻辑会更新过来。

## ins

插入一个元素。

```cpp
void ins(Val k) {
    if (!root) { // 树是空的，新建一个根
        root = ++tot;
        val[root] = k;
        cnt[root] = 1;
        pushup(root);
        return;
    }

    int u = root, v = 0; // v 一直保持是 u 的父亲
    while (true) {
        if (val[u] == k) { // 树里已有这个值
            cnt[u]++;
            pushup(u), pushup(v);
            splay(u); // 飞起来！
            return;
        }
        bool r = k > val[u];
        v = u, u = tr[u][r];
        if (!u) { // 树里没有这个值
            u = ++tot; // 新建节点
            val[u] = k;
            tr[v][r] = u;
            fa[u] = v;
            cnt[u] = 1;
            pushup(u), pushup(v);
            splay(u); // 飞起来！
            return;
        }
    }
}
```

## kth

查找第 $x$ 小的元素。

```cpp
Val kth(int x) {
    // 需要保证第 x 小的数存在
    int u = root;
    while (true) {
        if (tr[u][0] && x <= siz[tr[u][0]]) {
            u = tr[u][0];
        } else {
            x -= siz[tr[u][0]] + cnt[u];
            if (x <= 0) {
                splay(u); // 飞起来！
                return val[u];
            }
            u = tr[u][1];
        }
    }
    return 114514;
}
```

## rnk

查询元素 $k$ 的排名。**注意：需要保证 $k$ 存在**。

不存在的情况下，需要先 ins，查完之后 del。（当然我们现在还没有实现 del，因为 del 基于 `rnk_`）

```cpp
int rnk_(Val k) {
    // 需要保证 k 存在
    int u = root, ans = 1;
    while (true) {
        if (k < val[u])
            u = tr[u][0];
        else {
            ans += siz[tr[u][0]];
            if (k == val[u]) {
                splay(u); // 飞起来！
                return ans;
            }
            ans += cnt[u];
            u = tr[u][1];
        }
    }
    return 114514;
}
int rnk(Val k) {
    ins(k);
    int ans = rnk_(k);
    del(k);
    return ans;
}
```

## 辅助操作：根的 pre / nxt

注意到这两个函数是没有输入的，所以不是我们想要的那个 pre / nxt。

这两个函数返回根节点的 pre / nxt 节点。

```cpp
int pre() {
    int u = tr[root][0];
    while (tr[u][1])
        u = tr[u][1];
    splay(u); // 飞起来！
    return u;
}
int nxt() {
    int u = tr[root][1];
    while (tr[u][0])
        u = tr[u][0];
    splay(u); // 飞起来！
    return u;
}
```

有了这两个辅助操作之后，借助 `ins` 之后我们的值会被 `splay` 到顶的特性，我们希望的两个查询其实也很简单：

```cpp
Val pre(Val k) { // 操作：查询前驱
    ins(k);
    Val ans = val[pre()];
    del(k);
    return ans;
}
Val nxt(Val k) { // 操作：查询后继
    ins(k);
    Val ans = val[nxt()];
    del(k);
    return ans;
}
```

## del

先看代码：

```cpp
void clear(int u) {
    fa[u] = siz[u] = tr[u][0] = tr[u][1] = cnt[u] = 0;
    val[u] = 0;
}
void del(Val k) {
    rnk_(k); // 把 k 所在的点 splay 上来
    if (cnt[root] > 1) { // 这个点的 cnt > 1，直接在 cnt 上减
        cnt[root]--;
        pushup(root);
    } else if (!tr[root][0] && !tr[root][1]) { // 整棵树删没了
        clear(root);
        root = 0;
    } else if (!tr[root][0]) { // 没左儿子，右儿子上位
        int u = root;
        root = tr[u][1];
        fa[root] = 0;
        clear(u);
    } else if (!tr[root][1]) { // 没右儿子，左儿子上位
        int u = root;
        root = tr[u][0];
        fa[root] = 0;
        clear(u);
    } else { // 左右儿子都有
        int u = root;
        root = pre();
        fa[tr[u][1]] = root;
        tr[root][1] = tr[u][1];
        clear(u);
        pushup(root);
    }
}
```

这里有一个特别骚的操作就是，调用 `rnk_` 函数把这个元素给 splay 上来。

细说一下"左右儿子都有"这个部分：我们从左儿子的子树里取出一个最大的节点（即前面的辅助函数 pre），放到现在根节点的这个位置。

~~终于写完 Splay 的基本结构了。好累啊~~

# 平衡树的启发式合并

经过复杂的数学推导可以得到，Splay 和 Treap 的启发式合并是 $O(n \log n)$ 的，而不仅仅是预想中的 $O(n \log^2 n)$。

# 平衡树（Splay）维护序列 / 树

- 序列，插入 / 区间查询 - 见 "火星人" 一题。
- 树 DFS 序，子树查询 - 见 "Gty的游戏" 一题。

# 平衡树 例题

## [P4036 [JSOI2008] 火星人](https://www.luogu.com.cn/problem/P4036)【强制在线】(Medium)

✅️

> 维护一个字符串，多次询问两个后缀的 LCP，这个字符串还带修改和插入。【强制在线】
> 操作次数 $\le 1.5 \times 10^5$，字符串长度始终满足 $\le 10^5$。

P.S. 这个题有离线时光倒流线段树的做法。

看到**后缀 LCP**（后缀的前缀是区间）不难想到**二分 Hash**。又有修改，想到 [类似这样的题目](https://vjudge.net/problem/Gym-102163E)，这个题目可以使用 树状数组 / 线段树 来完成。

但是现在这个题还有插入，那就只能 Splay 了。当然块状链表也是可以的，但是我们暂时只考虑 polylog；当然无旋 Treap 也是可以的，但是我们暂时只考虑 Splay 做法。

Splay 维护序列的核心在于，**Splay 的中序遍历要保持是原序列**。

首先是插入操作：在 $x$ 和 $x+1$ 这两个 index 之间插入一个元素，我们可以先把 $x$ splay 到顶，然后把 $x+1$ splay 到 $x$ 的儿子。此时 $x+1$ 必没有左儿子，我们就可以把新的点放在这里。

然后是区间查询 Hash 值：把 $l-1$ splay 到顶，把 $r+1$ splay 到 $l-1$ 的儿子，此时 $r+1$ 的左子树就是全部的 $[l,r]$，也就是说我们需要查询这棵树的中序遍历 Hash 值，像线段树一样在 pushup 的时候一起维护就行了。

注意到如果我们的查询是 $[1,n]$，则会访问到 $0$ 和 $n+1$，我们额外把这两个节点添上去就行了，即初始的时候就放好这两个节点，甚至省去了特判空树的代码。

~~单点修改不用多说了吧，$x$ splay 到顶直接改就行了~~

总时间复杂度 $O(n \log^2 n)$。

```cpp
void insert(int x, Val k) {
    int u = kth(x), v = kth(x+1);
    splay(u);
    splay(v, u);
    int w = newNode();
    tr[v][0] = w;
    fa[w] = v;
    val[w] = k;
    splay(w);
}
void assign(int x, Val k) {
    int u = kth(x);
    splay(u);
    val[u] = k;
    pushup(u);
}
ull query_hash(int l, int r) {
    int u = kth(l-1), v = kth(r+1);
    splay(u);
    splay(v, u);
    return hsh[tr[v][0]];
}
```

## 课后作业 1 - [BZOJ3729 Gty的游戏](https://vjudge.net/problem/BZOJ-3729) (Hard)

> 给定一颗树，初始 $n$ 个结点，$1$ 为根节点。每个结点上有一定的石子数。
> 现在你需要在线支持三种操作：
> 1. 询问以 $x$ 为根的子树中进行组合游戏，双方轮流操作，每次操作可以将一个结点（在子树内且不为 $x$）的不超过 $L$ 个至少 $1$ 个石子移至其父亲结点。问这个游戏先手是否必胜？
> 2. 修改一个结点的石子数。
> 3. 新建一个结点石子数为 $x$，其父亲设为 $y$（保证 $y$ 已经建立）
> $n \le 10^5$。

可以在 [Hydro](https://hydro.ac/p/bzoj-P3729) 提交。

首先这个博弈论和其他部分看起来格格不入的，分析一下。

### 博弈论部分分析

以下**结论 0**、**结论 1** 和**结论 2** 都应该是熟知的。

- **结论 0：Nim 游戏的必胜条件是 $\bigoplus\limits_{i=1}^n a_i \ne 0$。**
- **结论 1：Nim 游戏（一次最多拿 $L$ 个）的必胜条件是 $\bigoplus\limits_{i=1}^n (a_i \bmod (L+1)) \ne 0$。**
  - 证明：一方拿了 $x$ 个时，另一方可以在同一堆拿 $L+1 - x$ 个，变到一个 $\bmod (L+1)$ 下相同的局面。也就是说我们在 $\bmod (L+1)$ 下玩 Nim 游戏即可。
- **结论 2：阶梯 Nim 游戏的必胜条件是 $\bigoplus\limits_{i \text{ is odd}} a_i \ne 0$。**
  - 证明：首先如果一方动了 $2i$ 处的石子，另一方就可以把这些石子直接送去 $2i-2$，最终到 $0$。也就是说偶数处都可以看作 $0$ 即终点。那么动奇数处的石子就相当于直接送进终点，也就是我们对所有奇数处的石子玩 Nim 游戏就行了。
- **结论 3：树上阶梯博弈的必胜条件是 $\bigoplus\limits_{dep_i \text{ is odd}} a_i \ne 0$。**
  - 证明：结论 2 的直接推论。
- **结论 4：树上阶梯博弈（一次最多拿 $L$ 个）的必胜条件是 $\bigoplus\limits_{dep_i \text{ is odd}} (a_i \bmod (L+1)) \ne 0$。**
  - 证明：结论 1 和结论 3 的直接推论。

所以我们把所有 $a_i$ 对于 $L+1$ 取模就行了，然后就不管 $L$ 了。然后我们需要维护同奇偶深度节点的异或和。

博弈论部分转化完毕。

### Splay 维护 DFS 序

子树询问，我们考虑把树拍成 DFS 序。在树上添加叶子就相当于在 DFS 序上插入，因此我们想到 Splay。

这题看起来似乎做完了，但是我们意识到做子树查询正常来说是需要维护子树大小的，此处不好做。

（以下防歧义，原树的节点用 $u,v$ 等字母，Splay 的节点用 $\alpha,\beta$ 等字母。）

（但是在代码中这两者可以混用。$u \to dfn_u \to \alpha$ 两层映射，我们可以直接让后面那层映射射回去来简化代码）

**Splay 维护 DFS 序的经典 Trick**：维护每个点在原树上的深度，对于节点 $u$ 找到 $dfn_u$ 之后的第一个满足 $dep_v \le dep_u$ 的节点 $v$，$[dfn_u, dfn_v)$ 就是以 $u$ 为根的子树占据的 $dfn$。

这个具体实现是，在 Splay 上维护 $\alpha$ 子树的节点中在原树上深度最小的那个节点的深度，不妨记为 $mn_\alpha$。我们从把 $dfn_u$ 对应的节点 $\alpha$ splay 到根，然后从 $\alpha$ 的右儿子开始找，通过维护的 $mn$ 定位到要找的节点 $\beta$，然后按照前面套路做就行了。把 $\text{pre}(\alpha)$ splay 到根，然后把 $\beta$ splay 到根的右儿子，取 $\beta$ 的左子树即可。

每次查询完 $\beta$ 之后，$\beta$ 都会紧接着在后面的操作被 splay 上去，所以复杂度应该是对的。

信息维护有点像 [ABC403G](https://www.luogu.com.cn/problem/AT_abc403_g) 这个题。

## [P4309 [TJOI2013] 最长上升子序列](https://www.luogu.com.cn/problem/P4309)【强制在线】(Easy)

> 共 $n$ 次操作，第 $i$ 次操作在第 $x_i$ 个数后插入数字 $i$ 并询问当前最长上升子序列。【强制在线】
> $n \le 10^5$。

$$f_i = \max\limits_{j<i \text{ and } a_j < a_i} f_j + 1$$

注意到每次插入的数是递增的，也就意味着包含这个数的 LIS 一定以这个数结尾。也就是对于这个特定的 $i$，有：

$$f_i = \max\limits_{j<i} f_j + 1$$

也就是说，我们要知道这个数的 $f$ 只需要查询前缀的 $f$ 最大值即可。

插入 + 前缀查询，Splay 秒了。

## [P4197 Peaks](https://www.luogu.com.cn/problem/P4197) (Easy)

✅️

类似题目：[P3359 改造异或树](https://www.luogu.com.cn/problem/P3359)

> 一个无向图，有边权和点权。若干个询问形如询问从点 $x$ 出发只能走边权不超过 $y$ 的边，走到所有点点权第 $k$ 大是多少。
> $n \le 10^5$、$0 \le m,q \le 5 \times 10^5$、值域 $10^9$。

最简单的一道题。

把所有询问离线按 $y$ 排序，转化为加边。每个连通块维护一个带 kth 功能的 set（pbds 可以实现），启发式合并做到 2log，如果不用 pbds 而是用 Splay 或 Treap 可以做到 1log。

TODO: 或许和题解区的线段树合并属于同一类型的做法？

# LCT - Link Cut Tree

[P3690 【模板】动态树（LCT）](https://www.luogu.com.cn/problem/P3690) ✅️

LCT 用于做一些动态树问题，即维护一个森林并支持一些加边删边操作（而且保持是森林）。

参考：
- [OI Wiki 的 LCT](https://oi-wiki.org/ds/lct/)
- [严格鸽 的 LCT](https://zhuanlan.zhihu.com/p/558363135)（不得不说鸽鸽的码风是真的好！）
- [2022 WC 的讲解](https://www.bilibili.com/video/BV1J44y1c76L/)

## 实链剖分

对于森林上一个节点，我们**任意**选取它的一个儿子作为实儿子（也可以不选），在他们之间连一条实边，在这个点和其他儿子之间连虚边。显然这样的剖分和重链剖分一样会产生很多由实边组成的实链。在后续的操作中我们会用 Splay 来维护这些实链。

正是因为实儿子可以任意选取，我们可以按需调整实链剖分的具体样子。

## 辅助树（Auxiliary Tree）

（左图：原树；右图：辅助树）

<img src="https://oi-wiki.org/ds/images/lct-access-1.svg" width="200" style="vertical-align: top;"/>
<img src="https://oi-wiki.org/ds/images/lct-access-2.svg" width="200" style="vertical-align: top;"/>

对于原树的每一个实链，我们使用一个 Splay 维护：Splay 的中序遍历为实链从上到下的顺序。

这些 Splay 也不是独立的，我们用原树上的虚边将这些 Splay 串起来。具体来说，对于原树上的一条虚边 $son \to fa$，我们找到 $son$ 所在的 Splay 的根 $rt$，在辅助树上连虚边 $rt \to fa$。

不难发现我们现在通过新的虚边将这些 Splay 串成了一整棵树，即辅助树。

注意，辅助树的实边和原树的实边没有一一对应的关系，例如上图中原树 $G \leftrightarrow H$ 这条实边就不存在于辅助树中。

实边和虚边在代码中的体现：
- 对于实边，儿子认父亲，父亲认儿子。
- 对于虚边，儿子认父亲，父亲不认儿子。

因为虚边的存在，辅助树不是二叉树。但是若只看实边，辅助树是二叉树森林，所以我们依然会用"左儿子""右儿子"这种说法。

## 重写基础工具包

```cpp
bool isroot(int u) { // u 是不是当前 Splay 的根
    return tr[fa[u]][0] != u && tr[fa[u]][1] != u;
}
void rotate(int u) {
    int v = fa[u], w = fa[v];
    bool r = dir(u);

    tr[v][r] = tr[u][!r];
    tr[u][!r] = v;
    if (!isroot(v)) tr[w][dir(v)] = u; // Here

    if (tr[v][r]) fa[tr[v][r]] = v;
    fa[v] = u;
    fa[u] = w;

    pushup(v), pushup(u);
}
void update(int u) {
    if (!isroot(u))
        update(fa[u]);
    pushdown(u);
}
void splay(int u) {
    update(u);
    while (!isroot(u)) { // Here
        int v = fa[u];
        if (!isroot(v)) // Here
            rotate(dir(u) == dir(v) ? v : u);
        rotate(u);
    }
}
```

## LCT 核心操作：access

这个操作的地位就类似于 Splay 中的 splay，接下来的一切其他操作围绕它展开，同时也是这个操作保证了 LCT 仅有 1log 的时间复杂度。

`access(u)` 代表让 $u$ 与原树根节点在同一条实链上，且 $u$ 是实链底部。

<img src="https://oi-wiki.org/ds/images/lct-access-3.svg" width="200" style="vertical-align: top;"/>
<img src="https://oi-wiki.org/ds/images/lct-access-7.svg" width="300" style="vertical-align: top;"/>

```cpp
void access(int u) {
    for (int v = 0; u; v = u, u = fa[u]) {
        splay(u);
        tr[u][1] = v;
        // 把右儿子从实边变虚边
        // 因为要保证原树上没有实儿子，右儿子代表的是深度大的点
        // 同时把上一次操作的点 v 接到右儿子，因为上一次操作的点肯定深度大
        pushup(u);
    }
}
```

根据 OI-Wiki，$n$ 个点执行 $m$ 次 `access` 的复杂度是 $O((n+m) \log n)$。也就是说均摊下来是 $\log$ 的。~~这句话是直接从上面 `splay` 复制过来的~~

## makeroot

`makeroot(u)` 代表把 $u$ 作为原树的新根节点，即平常说的换根。

我们可以先 `access(u)`，然后把 $u$ 所在的整条实链翻转（需要一个支持翻转的 Splay）。

```cpp
void makeroot(int u) {
    access(u);
    splay(u);
    maketag(u);
}
```

## findroot

`findroot(u)` 代表查找 $u$ 所在原树的根节点。

先 `access(u)`，然后把 $u$ splay 上去之后一路往左走，就可以找到深度最小的节点。找到之后要 splay 上去。

```cpp
int findroot(int u) {
    access(u);
    splay(u);
    while (tr[u][0])
        u = tr[u][0];
    splay(u);
    return u;
}
```

## split

`split(u, v)` 把 $u$ 和 $v$ 之间的路径弄成一条实链。并且在这之后 $u$ 是原树的根，$v$ 是 Splay 的根。

```cpp
void split(int u, int v) {
    makeroot(u);
    access(v);
    splay(v);
}
```

## link & cut

`link(u, v)` 在 $u$ 和 $v$ 之间连轻边即可。注意 $u$ 和 $v$ 原先不能在同一棵树上。

`cut(u, v)` 也好办，我们尝试把 $u \leftrightsquigarrow v$ 这条路径拿出来并且以 $v$ 为 Splay 根，如果拿完之后 $u$ 是 $v$ 的左儿子，且 $u$ 没有右儿子，说明这条边存在，完全删掉即可。

```cpp
bool link(int u, int v) {
    if (findroot(u) == findroot(v))
        return false;
    makeroot(u);
    fa[u] = v;
    return true;
}
bool cut(int u, int v) {
    split(u, v);
    if (tr[v][0] != u  || tr[u][1])
        return false;
    tr[v][0] = 0, fa[u] = 0;
    return true;
}
```

如果能够保证边存在，那么去掉两个 if 判断即可。

# LCT 维护子树信息

见 "共价大爷游长沙" 一题。

# 💡LCT 撤销

虽然 LCT 是均摊复杂度，但是它可以支持带撤销的东西，比如线段树合并。因为各种操作都有对应的相反操作，共享势能。例题：[P4319 变化的道路](https://www.luogu.com.cn/problem/P4319)，做法类似下面例题的魔法森林。

# LCT 例题

## 课后作业 1 - [P3203 [HNOI2010] 弹飞绵羊](https://www.luogu.com.cn/problem/P3203) (Easy)

✅️

> 有 $n$ 个点，每个点有一个系数 $a_i$，你处于位置 $i$ 可以走到 $i+a_i$，若 $i+a_i>n$ 则你走出了地图。现 $m$ 个操作有两种：1、把 $a_j$ 修改为 $k$。2、询问你位于点 $j$ 时，需要走多少步走出地图。$n \le 2 \times 10^5, m \le 10^5$。

首先发现整个玩意儿就是一个树（给"跳出"加一个虚拟的点 $n+1$），修改操作相当于 link & cut，所以非常自然想到 LCT。

询问也很简单，把 $j \leftrightsquigarrow n+1$ 这条路径拉出来，以 $j$ 为 Splay 根，查询 $j$ 在 Splay 上的子树大小 $-1$ 即可。

实现也是超级简单的：把所有点 $siz$ 初始化成 $1$，每次 `pushup` 里面更新就可以了。

## [P2387 [NOI2014] 魔法森林](https://www.luogu.com.cn/problem/P2387) (Medium)

类似题目：[P4172 [WC2006] 水管局长](https://www.luogu.com.cn/problem/P4172)

> 给定 $n$ 个点 $m$ 条边的无向图，每条边有两个权值 $a$ 与 $b$。求一条 $1$ 到 $n$ 的路径使得路径经过边的最大 $a$ 与最大 $b$ 的和最小。无法到达输出 $-1$。
> $n \le 5 \times 10^4, m \le 10^5$。

"$2$ 个权值" 这个条件有说法。我们不妨考虑一档自己造的部分分，所有 $b$ 都相等即只要考虑 $a$，立刻就能想到把所有边按 $a$ 排序之后依次加边的思路。

现在只多了一个权值，我们可以依然沿用刚才的思路，把所有边按 $a$ 排序后依次加边，但是用一些数据结构维护 $b$。我们需要在加边的同时维护 $1 \leftrightsquigarrow n$ 的最大值的最小值。

如果感觉这个过程有点像 Kruskal 那就对了，因为最小生成树就是满足任意 $u \leftrightsquigarrow v$ 上最大值最小的结构（这个东西叫**最小瓶颈路**）。我们考虑怎么在加边的同时维护最小生成森林。

考虑如果这张图原先是森林，当 $u \leftrightarrow v$ 这条边被加入时不是森林了，我们应该怎么让它变回森林。不难发现，我们只要把含有 $u,v$ 的这个环上的最大边删掉即可，当然最大边是 $u \leftrightarrow v$ 自己的情况要特判。

我们需要一个支持 加边 + 查询树链最大值 的结构，不难想到 LCT。

**Trick** LCT 维护边权，可以直接建虚点，将虚点点权设为这个边权。

\* 既然说到瓶颈相关的问题了，再补充一个结论：**最小生成树一定是最小瓶颈生成树**（充分非必要）。

## [#207. 共价大爷游长沙](https://uoj.ac/problem/207) (Hard)

✅️

> 有一棵树，会改变它的形态（每次操作删除一条边再加入一条边，保证依旧是棵树）。
> 有一个路径集合，初始为空，路径集合会被更改（每次操作加入一个点对 $(x,y)$ 表示路径，或者删去一个点对）。
> 询问操作是询问一条边是否被路径集合的所有路径经过。
> $n \le 10^5$。

首先这个题一股浓浓的随机化味道。

考虑怎么刻画"边在路径上"。一开始我尝试用 $\text{dis}$ 刻画，但是显然是不现实的。

**Trick** 在树上，如果边 $u \leftrightarrow v$ 属于树链 $x \leftrightsquigarrow y$，那么以 $u$ 为根的话，$v$ 的子树中只能有 $x$ 和 $y$ 中的一个。

有了这个从天而降的思路之后就非常简单了：给每组 $x$ 和 $y$ 赋相同随机权，把 $u$ 作为根求 $v$ 的子树异或和，如果这个异或和等于全部路径的权值异或和那么就大概率是 Yes，不等于则一定是 No。

这个东西就可以直接用 LCT 维护了。

### LCT 维护子树信息

我们尝试使用 LCT 维护子树异或和。

开三个数组 `val`、`siz`、`sizv` 分别代表节点本身的权值、节点在辅助树上的子树异或和、节点在辅助树上的所有虚子树异或和。注意，`siz` 包含节点自身，`sizv` 不包含。

具体来说，有关系：`siz[u] = val[u] ^ siz[tr[u][0]] ^ siz[tr[u][1]] ^ sizv[u];`。

我们要在每次出现虚实切换的时候维护好 `sizv`，并 `pushup` 同步到 `siz`。包含虚实切换操作的有 `access` 和 `link` 两个操作。

查询 $u$ 原树子树信息的时候，如果 $u$ 在辅助树上有实儿子，那么不能保证一定在其右边，所以直接查 `siz` 是不对的。但是，只要没有实儿子就是对的，因此我们把 $u$ 到 $v$ 单独拎出来，以 $v$ 为辅助树根，此时 `siz[u]` 就确确实实是原树上 $u$ 的子树异或和。

接下来给出这题的实现：

（注：因为异或的逆运算是自身，所以用"加"和"减"的注释代表是加上贡献还是去掉贡献。）

```cpp
Val val[MAXN], siz[MAXN] /*子树异或和*/, sizv[MAXN] /*虚子树异或和*/;

void pushup(int u) {
    siz[u] = val[u] ^ siz[tr[u][0]] ^ siz[tr[u][1]] ^ sizv[u];
}

void access(int u) {
    for (int v = 0; u; v = u, u = fa[u]) {
        splay(u);
        sizv[u] ^= siz[tr[u][1]]; // 加
        tr[u][1] = v;
        sizv[u] ^= siz[v]; // 减
        pushup(u);
    }
}

void link(int u, int v) {
    makeroot(u);
    fa[u] = v;
    // 先把 v 弄到辅助树的根才能直接修改 sizv
    access(v); splay(v);
    sizv[v] ^= siz[u]; // 加
    pushup(v);
}
void cut(int u, int v) {
    split(u, v);
    tr[v][0] = 0, fa[u] = 0;
    pushup(v);
}
void update_xor(int u, Val k) {
    // 先把 u 弄到辅助树的根才能直接修改 val
    access(u); splay(u);
    val[u] ^= k;
    pushup(u);
}
Val query(int u, int v) {
    split(u, v);
    return siz[u];
}
```

注：在其他人的题解中可能会出现非常匪夷所思的一种写法——在 `link` 中使用 `split(u, v)`，语义完全不 make sense。但是能够发现，其实就是把 `makeroot(u); access(v); splay(v);` 三个操作合在了一起，理论上是正确的。我觉得这种写法很莫名其妙，但是很多人都在使用，所以值得一提。

参考：

- 官方题解：[《共价大爷游长沙》解题报告](https://matthew99.blog.uoj.ac/blog/1771)
- [「题解」UOJ 207. 共价大爷游长沙](https://www.luogu.com/article/klbddc0z)
- [UOJ #207. 共价大爷游长沙（LCT + 异或哈希)](https://www.cnblogs.com/zjp-shadow/p/9725091.html)（码风超级好的野生题解！）

## [P4299 首都](https://www.luogu.com.cn/problem/P4299) (Hard)

> 一开始有 $n$ 个结点，没有边。有三种操作：
> - 将两个结点间连一条边，并且保证两个结点属不同联通块。
> - 询问一个联通块中所有点到其距离和最小的点。（有多个选择编号最小的）
> - 询问所有联通块中所有点到其距离和最小的点的异或和。
>
> $n \le 10^5$。

不难发现要求的这个点就是重心。回顾一下 [重心的性质 OI-Wiki](https://oi-wiki.org/graph/tree-centroid/)：
- 树中所有点到某个点的距离和中，到重心的距离和是最小的。
- 一棵树有 $1$ 个或 $2$ 个重心。若有 $2$ 个重心，则它们相邻。
- 以树的重心为根时，所有子树中最大子树的大小最小，且不超过整棵树大小的一半。
- 把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。
  - 在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。


TODO:

# 根号算法：分块 & 块状链表

这一类问题的思路是：先思考小数据时怎么做，合并又怎么做。

分块很熟悉了，什么是块状链表？

<img src="https://oi-wiki.org/ds/images/kuaizhuanglianbiao.png" width=400 />

~~每日任务：从 OI-Wiki 偷图~~

显然这样的结构和分块是大差不差的，只要每个块的大小都是 $O(B)$ 级别（$B$ 是块长）。而且相比分块来说，它还能支持插入。

一个小问题是，如果我一直在同一块上插入的话，块的大小就不是 $O(B)$ 然后就退化了。所以一般的解决办法是：当块的大小达到 $2B$ 时，暴力分裂成两个块。

# 根号算法 例题

## [P3203 [HNOI2010] 弹飞绵羊](https://www.luogu.com.cn/problem/P3203) (Medium)

上面已经有 LCT 思路了，接下来介绍一个绝妙的分块思路。

~~这个思路真的超级离谱啊，为什么会有人在这种题目想到分块啊……~~ 或许正是因为要维护的东西过于离谱吧。

对每个点维护 $step_i$ 和 $to_i$，分别表示跳出当前所在块需要的步数，以及跳到的位置。

查询非常直接：

```cpp
// 点的编号是 1~n 而非题目里的 0~(n-1)
int query(int x) {
    if (x > n)
        return 0;
    return query(to[x]) + step[x];
}
```

单点修改直接重构整个块即可。

查询 $O(\frac n B)$，单点修改 $O(B)$，平衡一下取 $B = \Theta(\sqrt n)$。总时间复杂度 $O(n \sqrt n)$。

## [P4278 带插入区间K小值](https://www.luogu.com.cn/problem/P4278) (Medium)

> 在线，序列，插入，单点修改，查询区间 k 小值。
> 操作数以及值域都在 $7 \times 10^4$ 以内。

首先带插入，所以想到平衡树和块状链表。平衡树又难写常数又大，所以我们想一下块状链表的思路。（注：本题确实有平衡树的 $\text{polylog}$ 做法）

联想到以前做过的 [P2801 教主的魔法](https://www.luogu.com.cn/problem/P2801)，在那题中我们实现了查询区间中 $\le k$ 的数的个数。

我们发现查询第 $k$ 小可以用二分答案以多一个 $\log V$ 的代价转化为上面的那个问题。然后就做完了。

---

时间复杂度分析。

认为 $n,q$ 同阶。

- 修改：$O(B)$（不重构时）
  - 有重构 $O(B \log B)$，重构总次数 $O(\frac n B)$，总复杂度 $O(n \log B)$，均摊下来 $O(\log B)$ 忽略。
- 查询：$O(\frac {n \log V} B \log B)$。

解得 $B = \Theta(\sqrt{n \log V (\log n + \log \log V)})$。若进一步认为 $n,V$ 同阶，则 $B = \Theta(\sqrt n \log n)$。实测开 $B = 512$ 能过，而且不卡常。

总结：$n,q,V$ 同阶的情况下，时间复杂度 $O(n \sqrt n \log n)$。

## [AT_joisc2014_c 歴史の研究](https://www.luogu.com.cn/problem/AT_joisc2014_c)【强制在线】(Medium)

类似题目：[P4168 [Violet] 蒲公英](https://www.luogu.com.cn/problem/P4168)

> 求区间加权众数（$x$ 乘上 $x$ 的出现次数 的最大值）。
> $n,q \le 10^5$，值域 $10^9$。

众所周知这两个题离线的话就是回滚莫队的板子。但是现在被强制在线了，我们只能用分块了。

对于这一类高级分块问题，我们一般采取的思路是：预处理 $ans_{L,R}$ 表示第 $L$ 块到第 $R$ 块的答案，然后每次查询的时候扫描散块的剩余部分来计算影响。

这么说太抽象了，我们来看具体的思路：

首先起手一个离散化。设 $ans_{i,j}$ 表示第 $i$ 块到第 $j$ 块的加权众数，再设一个 $sum_{i,v}$ 表示前 $i$ 块中 $v$ 的出现次数，方便后面计算。

这两个数组都可以 $O(n \sqrt n)$ 预处理，这里讲一下 $ans$：$O(\sqrt n)$ 枚举 $i$，$O(\sqrt n)$ 枚举 $j$，再开一个 $O(\sqrt n)$ 大小的桶就行了。

询问 $[l,r]$ 时，我们先把答案预设为当中整块的答案 $ans_{i,j}$，然后扫描散块，看看散块中出现的加权众数有没有比 $ans_{i,j}$ 大，这里需要用到 $sum$ 数组。

## [P4135 作诗](https://www.luogu.com.cn/problem/P4135)

> 求区间内出现次数为正偶数的数的个数。强制在线。

和上面那题做法一模一样。

## [BZOJ3744 Gty的妹子序列](https://vjudge.net/problem/BZOJ-3744) | [P5046 [Ynoi2019 模拟赛] Yuno loves sqrt technology I](https://www.luogu.com.cn/problem/P5046)

[hydro](https://hydro.ac/p/bzoj-P3744)

> 查询静态区间逆序对。强制在线。
> $n,m \le 5 \times 10^4$ \| $n,m \le 10^5$。

TODO:

## [BZOJ3787 Gty的文艺妹子序列](https://vjudge.net/problem/%E9%BB%91%E6%9A%97%E7%88%86%E7%82%B8-3787) (Hard)

[hydro](https://hydro.ac/p/bzoj-P3787)

> 支持单点修改的上面那题。强制在线。

TODO:

## 课后作业 3 - [P2137 Gty的妹子树](https://www.luogu.com.cn/problem/P2137)

TODO:

# 莫队 & 带修莫队 & 树上莫队

TODO:

# 莫队 例题

### [BZOJ3809 Gty的二逼妹子序列](https://vjudge.net/problem/BZOJ-3809) | [P4867 Gty的妹子序列](https://www.luogu.com.cn/problem/P4867)

修改次数 $O(n \sqrt n)$，询问次数 $O(n)$

修改复杂度 $O(1)$，询问复杂度 $O(\sqrt n)$。

TODO:

## [P4074 [WC2013] 糖果公园](https://www.luogu.com.cn/problem/P4074)

TODO:





# 可持久化

## 标记永久化

不下传标记，只在查询的时候考虑。

## Path Copy

线段树、Trie、左偏树、无旋 Treap

注意到无旋 Treap 每次修改 $\log$ 个点，path copy

# 例题

## [P5283 [十二省联考 2019] 异或粽子](https://www.luogu.com.cn/problem/P5283)

$O((n+k) \log V)$

### 可持久化做法

TODO:

### 无可持久化做法

[](https://www.luogu.com.cn/article/ipa5pxaj)

TODO:

### 加强：$k = O(n^2)$

用二分求第 $k$ 大

TODO:

$\sum\limits_{v \in S} (v \oplus s_i)$，拆位维护 $\Theta(\log V)$ 个前缀和

$O(n \log^2 V)$

## [P3402 可持久化并查集](https://www.luogu.com.cn/problem/P3402)

不能路径压缩（均摊复杂度，错的）。

启发式合并，用可持久化数组维护 $fa$ 和 $siz$。$O(n \log^2 n)$。

## [BZOJ4668 冷战](https://hydro.ac/p/bzoj-P4668)

神题。

我想的：倍增 + LCA，时间 1log，空间 1log

**Trick** TODO:

## [P3295 [SCOI2016] 萌萌哒](https://www.luogu.com.cn/problem/P3295)

神题。

倍增并查集

连边 $(i,j) \leftrightarrow (\text{find}_{j+1}(i), j)$

TODO:

## [#14. 【UER #1】DZY Loves Graph](https://uoj.ac/problem/14)

**Trick** 离线 & 撤销的不是撤销 -> 势能分析

TODO:

# 可并堆

平衡树可以完全覆盖可并堆的功能……但是可并堆常数小。

[P3377 【模板】左偏树/可并堆](https://www.luogu.com.cn/problem/P3377)

TODO:

# 可持久化无旋 Treap

无旋 Treap：随机权满足堆的性质，权满足 BST 的性质



TODO:

## [P5055 【模板】可持久化文艺平衡树](https://www.luogu.com.cn/problem/P5055)

模板题。

TODO:




# 静态链分治

$\sum\limits_{u=1}^n siz_u - siz_{hson_u} = O(n \log n)$

## [CF208E Blood Cousins](https://www.luogu.com.cn/problem/CF208E)

**套路** 把询问挂到子树上

TODO:

## [P4149 [IOI 2011] Race](https://www.luogu.com.cn/problem/P4149)

**套路** 简单路径，挂在 LCA 上

桶

TODO:

$O(n \log n)$。

## [CF741D Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths](https://www.luogu.com.cn/problem/CF741D)

想出了完整思路！！

TODO:


# 整体二分 & CDQ

$O((n+m) \log n)$ 离线静态区间 k 小值

## [P3332 [ZJOI2013] K大数查询](https://www.luogu.com.cn/problem/P3332)

TODO:

## [P4093 [HEOI2016/TJOI2016] 序列](https://www.luogu.com.cn/problem/P4093)

TODO:

比较裸的三维偏序。$O(n \log^2 n)$。

## [P4095 [HEOI2013] Eden 的新背包问题](https://www.luogu.com.cn/problem/P4095)

TODO:

扣掉一个 -> 由 log 个区间拼出来


# 点分治

## 颜色树

TODO:

> 神秘黑科技 $O(n + \sqrt V)$ 排序

## [P10632 Normal](https://www.luogu.com.cn/problem/P10632)

TODO:

点分树

$$\sum \sum \frac 1 {dis(i, j)}$$





万金油 LCT
万金油 分块
偏卡常：树剖 / 静态链分治
