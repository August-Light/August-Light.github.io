https://www.luogu.com.cn/contest/261748
https://www.luogu.com.cn/discuss/1132851

# 我的错题

- 2
- 16
- 24 25 26
- 27 28 30 31 32
- 36

得分：70.5

# 单选

> 2. 你使用 g++ -O2 -o myapp main.cpp 命令编译了一个程序，然后尝试用 gdb ./myapp
进行调试。在 GDB 中，当你试图使用 print 命令查看某个局部变量的值时，最有可能遇到
的情况是？（ ）
A. 程序立即崩溃，因为 GDB 无法处理优化过的代码。
B. 变量值可以被正常显示，但执行速度会变慢。
C. GDB 会自动重新以 -g 选项编译该程序。
D. 以上三者都错误。
>
> 答案：D

首先 B 肯定不对，因为 O2 优化之后原先的变量信息会丢失。

然后 A 和 C 是不对的，不对就是不对。

According to ChatGPT，实际上的情况是，因为没有加 `-g` 所以不会生成调试符号，大概只能看汇编。

> 10. 某递归函数的递推式为 $T(n) = 3 T(\frac n 4) + \Theta(n^{1.2})$，则其渐进时间复杂度为？
>
> 答案：$\Theta(n^{1.2})$

![](https://cdn.luogu.com.cn/upload/image_hosting/fve8hb8w.png)

（第二类有一个扩展版，如果不是 $\Theta(n^d)$ 而是 $\Theta(n^d \log^k n)$ 的形式，那么最后的结果是 $\Theta(n^d \log^{k+1} n)$。比如 $T(n) = 2 T(\frac n 2) + \Theta(n \log n) = \Theta(n \log^2 n)$）

总结：**$d$ 大则看 $d$，$\log_b a$ 大则看 $\log_b a$，一样大则多 1log**。

（这里的说法都是不严谨的，严谨的版本在 [重谈主定理（master定理）及其证明](https://www.luogu.com.cn/article/w3avh1ku)）

对于此题，$\log_b a = \log_4 3 < 1.2$，属于第一种，所以就是 $\Theta(n^{1.2})$。

# 阅读理解

## 2

绷不住，考场上没看出是拉格朗日插值，变换半天似乎把牛顿插值公式变换出来了。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int N = 1010;

int n, m, mod;
long long ans, y[N], f[N], g[N], p[N], s[N];

long long qmi(long long a, int b, int p) {
    long long res = 1;
    while (b) {
        if (b & 1)
            res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

long long solve(int n, int k) {
    memset(y, 0, sizeof(y));
    memset(f, 0, sizeof(f));
    memset(g, 0, sizeof(g));
    memset(p, 0, sizeof(p));
    memset(s, 0, sizeof(s));

    for (int i = 1; i <= k + 2; i++)
        y[i] = (y[i - 1] + qmi(i, k, mod)) % mod;

    f[0] = g[0] = 1;
    for (int i = 1; i <= k + 2; i++)
        f[i] = f[i - 1] * i % mod;
    for (int i = 1; i <= k + 2; i++)
        g[i] = -g[i - 1] * i % mod;

    p[0] = s[k + 3] = 1;
    for (int i = 1; i <= k + 2; i++)
        p[i] = p[i - 1] * (n - i) % mod;
    for (int i = k + 2; i >= 1; i--)
        s[i] = s[i + 1] * (n - i) % mod;

    long long ans = 0;
    for (int i = 1; i <= k + 2; i++) {
        long long t1 = p[i - 1] * s[i + 1] % mod;
        long long t2 = f[i - 1] * g[abs(k - i + 2)] % mod;
        (ans += y[i] * t1 % mod * qmi(t2, mod - 2, mod) % mod) %= mod;
        ans = (ans + mod) % mod;
    }
    return ans;
}

int main() {
    scanf("%d%d%d", &n, &m, &mod);
    long long res = 0;
    for (int i = 1; i <= n; i++) {
        res += (n - i + 1) * qmi(m, n - i, mod) % mod * solve(m, i);
        res %= mod;
    }
    printf("%lld", res);
    return 0;
}
```

> 证明：这段代码计算了：长度为 $m$，值域为 $[1,n]$ 的所有正整数序列的 $\sum\limits_{i=1}^m \sum\limits_{j=i}^m \min\limits_{k=i}^j a_k$ 之和。

- $y_i = \sum\limits_{j=1}^i j^k$
- $f_i = i!$
- $g_i = (-1)^i i!$
- $p_i = \prod\limits_{j=1}^i (m-j)$
- $s_i = \prod\limits_{j=i}^{k+2} (m-j)$

注意到变量 $t_1$ 这里的结构是 $\prod\limits_{j \ne i, j \in [1,k+2]} (m-j)$，联想到拉格朗日插值公式

$$f(k) = \sum\limits_{i=1}^n y_i \prod\limits_{j \ne i} \frac {k - x_j} {x_i - x_j}$$

的连续点值情况：

$$f(k) = \sum\limits_{i=1}^n y_i \frac {\prod\limits_{j=1}^{i-1} (k-j) \times \prod\limits_{j=i+1}^n (k-j)} {(-1)^{n-i} (i-1)! (n-i)!}$$

完美对上。因此判断出是在对 $y_i = \sum\limits_{j=1}^i j^k$ 进行拉格朗日插值（$k+2$ 也能对上），`solve(n, k)` 算出来的就是 $\sum\limits_{j=1}^n j^k$。

看一下主函数在干嘛：

$$\begin{aligned}
    & \sum\limits_{i=1}^n (n-i+1) m^{n-i} \sum\limits_{j=1}^m j^i \\
\end{aligned}$$

TODO: